# Avito Trainee

## Запуск сервиса

Сервис написанный на `golang` запускается в `docker` контейнере. 

В проекте используется `Makefile`.

## Шаги запуска сервиса

1. Склонируйте репозиторий на компьютер.
2. Создайте `.env` файл в корне проекта. Образец лежит в корне проекта под названием `.env.example`
3. (опционально) запустите сборку основного приложения - `make build`
4. Запустите приложение `make run`. База данных автоматически запуститься. Миграции накатятся автоматически.

## О приложении

**По умолчанию приложение запускается по 8002 порту и доступно по адресу** `http://localhost:8002/api/v0/`

### GORM или голые SQL запросы

В приложении я решил использовать GORM для SQL запросов.

**Почему GORM?** Ответ банален - исключительно для простоты разработки. В проекте не используются сложные аналитические запросы с большим количеством `join` и прочего крутого чего умеют реляционные БД. Поэтому, почему бы и нет?

Да, я теряю в производительности приложения, зато я повышаю свою эффективность меньше думая о запросах к базе данных.

Даже если мне нужно использовать какой-то сложный и с первого взгляда нетривиальный `sql` запрос, в GORM такое возможно.

### Добавление пользователя в сегмент

Изначально я некорректно прочитал ТЗ и реализовал создание самого сегмента с возможностью задать ему время жизни. Но за день до сдачи проекта я перечитал ТЗ и обнаружил эту деталь.

Я оставил два варианта - возможность задать TTL самому сегменту (после удаления сегмента все связи с пользователями удаляются и пишутся в историю), а так же то что требовалось по ТЗ - при добавлении сегмента к пользователю можно указать TTL.

НО, TTL задаётся для всех сегментов, а не для отдельно каждого. Сделано так из-за нехватки времени. Так то можно сделать, что-бы для каждого добавляемого сегмента можно было задать TTL.

**Важная деталь про TTL.**

Дата TTL возвращается во времени UTC. Обрабатывается на сервере так же в UTC.

Для ввода TTL я вдохновился полем трекинга времени в таск трекере Jira.

```
1y (1 год)
2w (2 недели)
3d (3 дня)
4h (4 часа)
5m (5 минут)
6s (6 секунд)
```

При этом их можно использовать вместе.

```
2w 3d 15h (now + 2 weeks + 3 days + 15 hours)
2d 5m (now + 2 days + 5 minutes)
```

## Документация проекта

Для документации я использовал Postman Collection.

Документация прописана в Postman файле. После импорта `.json` файла тыкните по коллекции пкм -> View documentation. Там все детали реализации. А просто примеры запроса и ответа.. ну вы знаете.

### Получение сегмента по name

Для получения сегмента по его name я использовал `path` параметр.

Это не совсем очевидный и правильный подход, если придерживаться `REST API` принципов. Упомянул про это так как считаю важно про это знать.

## `Makefile`

В проекте используется `Makefile`.

`make build` - для сборки `docker` контейнера. Можно и не собирать, образ залит на docker.io registry. При запуске `docker compose` образ сам подтянется. 

`make run` - для запуска сервиса. Автоматически запустится и база данных `postgresql`

`make shutdown` - для остановки сервиса.
